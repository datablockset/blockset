use core::panic;

use crate::digest224::Digest224;

use super::{div_rem::div_rem, from_base32, to_base32};

pub type Name = [u8; 45];

pub const fn to_name(h: &Digest224) -> Name {
    const fn f(h: &Digest224, i: usize) -> u8 {
        let (d, r) = div_rem(i * 5, 32);
        let mut x = h[d] >> r;
        let size = 32 - r;
        if size < 5 && d < 6 {
            x |= h[d + 1] << size
        }
        to_base32(x as u8)
    }
    [
        f(h, 0),
        f(h, 1),
        f(h, 2),
        f(h, 3),
        f(h, 4),
        f(h, 5),
        f(h, 6),
        f(h, 7),
        f(h, 8),
        f(h, 9),
        //
        f(h, 10),
        f(h, 11),
        f(h, 12),
        f(h, 13),
        f(h, 14),
        f(h, 15),
        f(h, 16),
        f(h, 17),
        f(h, 18),
        f(h, 19),
        //
        f(h, 20),
        f(h, 21),
        f(h, 22),
        f(h, 23),
        f(h, 24),
        f(h, 25),
        f(h, 26),
        f(h, 27),
        f(h, 28),
        f(h, 29),
        //
        f(h, 30),
        f(h, 31),
        f(h, 32),
        f(h, 33),
        f(h, 34),
        f(h, 35),
        f(h, 36),
        f(h, 37),
        f(h, 38),
        f(h, 39),
        //
        f(h, 40),
        f(h, 41),
        f(h, 42),
        f(h, 43),
        f(h, 44),
    ]
}

pub const fn from_name(b: &Name) -> Digest224 {
    const fn f(b: &Name, i: usize) -> u32 {
        const fn g(b: &Name, d: usize, i: usize) -> u64 {
            if let Some(result) = from_base32(b[d + i]) {
                (result as u64) << (i * 5)
            } else {
                panic!("invalid base32")
            }
        }
        let (d, r) = div_rem(i << 5, 5);
        let x = g(b, d, 0)
            | g(b, d, 1)
            | g(b, d, 2)
            | g(b, d, 3)
            | g(b, d, 4)
            | g(b, d, 5)
            | g(b, d, 6);
        (x >> r) as u32
    }
    [
        f(b, 0),
        f(b, 1),
        f(b, 2),
        f(b, 3),
        f(b, 4),
        f(b, 5),
        f(b, 6),
    ]
}

#[cfg(test)]
mod tests {
    use super::{from_name, to_name};

    #[test]
    fn test() {
        fn f(a: [u32; 7], b: &[u8; 45]) {
            assert_eq!(to_name(&a), *b);
            assert_eq!(from_name(b), a);
        }
        f([0; 7], &[b'0'; 45]);
        f(
            [1, 0, 0, 0, 0, 0, 0],
            b"100000000000000000000000000000000000000000000",
        );
        f(
            [0b11_00010, 0, 0, 0, 0, 0, 0],
            b"230000000000000000000000000000000000000000000",
        );
        f(
            [0b110_00101_00100, 0, 0, 0, 0, 0, 0],
            b"456000000000000000000000000000000000000000000",
        );
        f(
            [0b1010_01001_01000_00111, 0, 0, 0, 0, 0, 0],
            b"789a00000000000000000000000000000000000000000",
        );
        f(
            [0b1111_01110_01101_01100_01011, 0, 0, 0, 0, 0, 0],
            b"bcdef0000000000000000000000000000000000000000",
        );
        f(
            [0b10101_10100_10011_10010_10001_10000, 0, 0, 0, 0, 0, 0],
            b"ghjkmn000000000000000000000000000000000000000",
        );
        f(
            [0b11011_11010_11001_11000_10111_10110, 0, 0, 0, 0, 0, 0],
            b"pqrstv000000000000000000000000000000000000000",
        );
        f(
            [
                0b00_11101_11110_11111_11110_11101_11100,
                0b111,
                0,
                0,
                0,
                0,
                0,
            ],
            b"wxyzyxw00000000000000000000000000000000000000",
        );
        f(
            [
                0xC000_0000,
                0b0101_10110_10111_11000_11001_11010_110,
                1,
                0,
                0,
                0,
                0,
            ],
            b"000000vtsrqpn00000000000000000000000000000000",
        );
        f(
            [
                0b_01_10010_00100_01101_00001_11011_00001, // 1V1D4J
                0b_1110_11001_01010_01100_11001_00100_010, // 94SCAS
                0b0_11000_11111_11110_01100_10000_10111_0, // EQGCYZR
                0b_010_11101_01101_00101_01010_10001_0000, // 0HA5DX
                0b_10110_10110_00110_11101_11000_01001_01, // A9RX6PP
                0b_11_01100_01101_10101_01011_01111_10101, // NFBNDC
                0b_0011_01100_01010_00001_00111_01001_100, // K971AC3
            ],
            b"1v1d4j94scaseqgcyzr0ha5dxa9rx6ppnfbndck971ac3",
        );
    }
}
