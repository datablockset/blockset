use std::iter::once;

use crate::{
    base32::{decode, encode},
    bit_vec32::BitVec32,
    digest224::Digest224,
};

pub fn to_name(h: &Digest224) -> String {
    let mut i = h
        .iter()
        .map(|x| BitVec32::new(*x, 32))
        .chain(once(BitVec32::new(0, 1)));
    let (result, a) = encode(&mut i);
    assert_eq!(a.len, 0);
    assert_eq!(a.v, 0);
    assert_eq!(result.len(), 45);
    result
}

pub fn to_digest224(h: &str) -> Option<Digest224> {
    let (vec, a) = decode(&mut h.chars())?;
    if vec.len() != 7 {
        return None;
    }
    assert_eq!(a.len, 1);
    assert_eq!(a.v, 0);
    let mut result = Digest224::default();
    result.copy_from_slice(&vec);
    Some(result)
}

#[cfg(test)]
mod tests {
    use crate::name::{to_digest224, to_name};

    #[test]
    fn test() {
        fn f(a: [u32; 7], b: &str) {
            assert_eq!(to_name(&a), *b);
            assert_eq!(to_digest224(b), Some(a));
        }
        f([0; 7], "000000000000000000000000000000000000000000000");
        f(
            [1, 0, 0, 0, 0, 0, 0],
            "100000000000000000000000000000000000000000000",
        );
        f(
            [0b11_00010, 0, 0, 0, 0, 0, 0],
            "230000000000000000000000000000000000000000000",
        );
        f(
            [0b110_00101_00100, 0, 0, 0, 0, 0, 0],
            "456000000000000000000000000000000000000000000",
        );
        f(
            [0b1010_01001_01000_00111, 0, 0, 0, 0, 0, 0],
            "789a00000000000000000000000000000000000000000",
        );
        f(
            [0b1111_01110_01101_01100_01011, 0, 0, 0, 0, 0, 0],
            "bcdef0000000000000000000000000000000000000000",
        );
        f(
            [0b10101_10100_10011_10010_10001_10000, 0, 0, 0, 0, 0, 0],
            "ghjkmn000000000000000000000000000000000000000",
        );
        f(
            [0b11011_11010_11001_11000_10111_10110, 0, 0, 0, 0, 0, 0],
            "pqrstv000000000000000000000000000000000000000",
        );
        f(
            [
                0b00_11101_11110_11111_11110_11101_11100,
                0b111,
                0,
                0,
                0,
                0,
                0,
            ],
            "wxyzyxw00000000000000000000000000000000000000",
        );
        f(
            [
                0xC000_0000,
                0b0101_10110_10111_11000_11001_11010_110,
                1,
                0,
                0,
                0,
                0,
            ],
            "000000vtsrqpn00000000000000000000000000000000",
        );
        f(
            [
                0b_01_10010_00100_01101_00001_11011_00001, // 1V1D4J
                0b_1110_11001_01010_01100_11001_00100_010, // 94SCAS
                0b0_11000_11111_11110_01100_10000_10111_0, // EQGCYZR
                0b_010_11101_01101_00101_01010_10001_0000, // 0HA5DX
                0b_10110_10110_00110_11101_11000_01001_01, // A9RX6PP
                0b_11_01100_01101_10101_01011_01111_10101, // NFBNDC
                0b_0011_01100_01010_00001_00111_01001_100, // K971AC3
            ],
            "1v1d4j94scaseqgcyzr0ha5dxa9rx6ppnfbndck971ac3",
        );
    }
}
